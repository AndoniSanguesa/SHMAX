import numpy as np
import os
import matplotlib.pyplot as plt
import wave
import contextlib
from pycochleagram.cochleagram import cochleagram
from skimage.util import view_as_windows as viewW


def col2im(image_blocks, block_size, image_size):
    """
    Rearranges matrix columns into blocks

    :param image_blocks: (array-like) image blocks
    :param block_size: (array-like) size of blocks
    :param image_size: (ndarray) size of image to fit blocks into
    :return:
    """
    m,n = block_size
    mm,nn = image_size
    return image_blocks.reshape(nn-n+1,mm-m+1).T


def im2col(image, block_size, stepsize=1):
    """
    Rearrange image blocks into columns

    :param image: (array-like) The image to be rearranged
    :param block_size: (array-like) Size of blocks as tuple
    :param stepsize: (int) Stepsize to emulate the Matlab `sliding`
    :return: (ndarray) rearranged image
    """

    return viewW(image, (block_size[0],block_size[1])).reshape(-1,block_size[0]*block_size[1]).T[:,::stepsize]


def sample_images_3d(sample_size, base_size, path):
    """
    Samples 3d images for patches used to train bases.

    :param sample_size: (int) desired size of sample
    :param base_size: (int) desired size of base
    :param path: (Stirng) path to data files
    :return: (ndarray) samples as column vectors. Size: (base_size^2, sample_size)
    """

    print(f"*** Generating {sample_size} 3D samples from data ***")
    files = list(filter(lambda x: x.startswith("pool"), os.listdir(path)))
    n = min(len(files), 5000)
    samples_per_image = sample_size / n
    test_file = np.load(path+"/"+files[0])
    X = np.zeros(base_size^2 * test_file.shape[2], sample_size)

    for i in range(n):
        print(f"{round((i/n)*100, 0)}%")
        file = files[i]
        data = np.load(path+"/"+file)
        x_vals = np.floor(np.random.rand(samples_per_image) * (data.shape[0] - base_size)).astype(int)
        y_vals = np.floor(np.random.rand(samples_per_image) * (data.shape[1] - base_size)).astype(int)
        for j in range(samples_per_image):
            patch = data[x_vals[j]:x_vals[j]+base_size, y_vals[j]:y_vals[j]+base_size, :]
            X[:,i*samples_per_image+j] = np.reshape(patch, ((base_size**2)*data.shape[2]))

    return np.asfortranarray(X, dtype="double")


def sample_images_2d(sample_size, base_size, path):
    """
    Samples 2d images for patches used to train bases.

    :param sample_size: (int) desired size of sample
    :param base_size: (int) desired size of base
    :param path: (Stirng) path to data files
    :return: (ndarray) samples as column vectors. Size: (base_size^2, sample_size)
    """

    print(f"*** Generating {sample_size} 2D samples from data ***")
    files = os.listdir(path)
    n = min(len(files), 5000)
    samples_per_image = int(sample_size // n)
    X = np.zeros((base_size**2, int(sample_size)))

    for i in range(n):
        print(f"{round((i / n) * 100, 3)}%")
        file = files[i]
        coch_info = np.load(path+"/"+file)
        features = generate_features(coch_info["waveform"], sr=16000)
        x_vals = np.floor(np.random.rand(samples_per_image) * (features.shape[0] - base_size)).astype(int)
        y_vals = np.floor(np.random.rand(samples_per_image) * (features.shape[1] - base_size)).astype(int)
        for j in range(samples_per_image):
            patch = features[x_vals[j]:x_vals[j]+base_size, y_vals[j]:y_vals[j]+base_size]
            X[:,i*samples_per_image+j] = np.reshape(patch, (base_size**2))

    return np.asfortranarray(X, dtype="double")


def get_wav_duration(path):
    """
    Returns duration of specified wav file in seconds

    :param path: Path to wav file
    :return: (float) duration of wav file in seconds
    """

    with contextlib.closing(wave.open(path, 'r')) as f:
        frames = f.getnframes()
        rate = f.getframerate()
        duration = frames / float(rate)
        return duration


def generate_features(waveform, n_features=194, sr=1):
    """
    Generates a feature vector from cochleogram subbands given a waveform.

    :param waveform: (ndarray) array represnting waveform
    :param n_features: (int) number of features/subbands desired
    :param sr: (int) sampling rate that original wav was recorded in
    :return: (ndarray) list of subbands representing features
    """
    return cochleagram(waveform, sr, n_features, 0, 7630, 1, strict=False, ret_mode="subband")


def save_coch_to_file(coch, wav_len=None, wav_path=None, train=None, region=None, speaker=None,
                      phone=None, words=None, text=None, prompt=None, waveform=None, name=None):
    """
    Saves cochleogram to npz file for later use. Could be used to generate file in WSL and plotted on Windows for
    instance.

    :param coch: (ndarray) the cochleogram representation generated by lyon
    :param wav_len: (float) length of wav file in seconds
    :param wav_path: (String) Length of wav recording
    :param train: (bool) True if data belongs to training set, False otherwise
    :param region: (int) Region for speaker
    :param speaker: (String) Speaker identifier
    :param phone: (String) Phoneme transcription with time bounds for each phoneme
    :param words: (String) Text being read with time bounds for each word
    :param text: (String) full text being read, bounds only provided for full prompt
    :param prompt: (String) Prompt identifier
    :param waveform: (ndarray) array representation of wav file
    :param name: (String) Name of file to sve to. Defaults to metadata info.
    :return: None
    """
    path = ""
    if train is not None:
        path = "./pydata/" + ("TRAIN/" if train else "TEST/")
        os.makedirs(os.path.dirname(path), exist_ok=True)

    if not name:
        name = f"{'train' if train else 'test'}-{region}-{speaker}-{prompt}"

    path += name

    np.savez(path,
             coch=coch,
             wav_len=wav_len,
             wav_path=wav_path,
             train=train,
             region=region,
             speaker=speaker,
             phone=phone,
             words=words,
             text=text,
             waveform=waveform)


def load_coch_from_file(path):
    """
    Loads cochleogram and sample rate(if specified) from file.

    :param path: (String) path to file npz file cochleogram and sample rate was saved to
    :return: (cochleogram, wav_len) --> (ndarray of size [N / decimation_factor, channels], float)
    """

    return np.load(path)


def plot_coch(coch, wav_len=None, name=None):
    """
    Plots cochleogram using matplotlib's pyplot.

    :param coch: ndarray representation of cochleogram
    :param wav_len: (float) Length of wav file in seconds
    :param name: (String) name of wav file. Used for plot title
    :return: None
    """

    xs = []
    ys = []
    zs = []

    y_size, x_size = coch.shape

    for y_val in range(y_size):
        for x_val in range(x_size):
            xs.append(x_val/x_size * wav_len if wav_len else x_val)
            ys.append(y_val)
            zs.append(coch[y_val][x_val])

    plt.scatter(xs, ys, c=zs, cmap="viridis")
    plt.xlabel("seconds")
    if name:
        plt.title(f"{name}")
    else:
        plt.title(f"Cochleogram")
    plt.show()

coch_info = load_coch_from_file("pydata/TEST/test-1-FAKS0-SA2.npz")